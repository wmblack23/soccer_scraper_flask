# -*- coding: utf-8 -*-#!/usr/bin/env python# coding: utf-8# Notebook scrapes fixture data from: https://www.bbc.com/sport/football/scores-fixtures# In[ ]:      from flask import Flask, render_templatefrom flask import requestimport requestsfrom bs4 import BeautifulSoupfrom datetime import date as mydatefrom datetime import datetime as mydatetimeimport os, pytz, datetime, reimport time as mytime    def swap_positions(list, pos1, pos2):    """    Function to swap item positions in a list.        Called later    """        list[pos1], list[pos2] = list[pos2], list[pos1]# In[ ]:def clean_data(list):        """    Changing all instances of 'Premier League' to 'English Premier League' for better consistency.    Also chops away all unnecessary string data.        Called later    """        prem_header = ">Premier League</h3>"    EPL_header = ">English Premier League</h3>"    prem_span = "$0Premier League"    EPL_span = "$0English Premier League"    for indx, item in enumerate(list):        if prem_header in item:            list[indx] = list[indx].replace(prem_header, EPL_header)        elif prem_span in item:            list[indx] = list[indx].replace(prem_span, EPL_span)        else:            item    leagues = (['English Premier League', 'Spanish La Liga',  'German Bundesliga',  'Italian Serie A',             'French Ligue 1', 'Champions League', 'Europa League'])        list = [i[-135:] for i in list]    left, right = '">', '</'    list = [[l[l.index(left)+len(left):l.index(right)] for l in list if i in l] for i in leagues]        return list# In[ ]:def home_and_away(list):        """    For games that haven't occured yet, our scraper will return Home Team, Away Team, and game time.    There will be an empty spot '' where our scraper tried to scrape the minute the game is in, but since    the game has yet to start it is empty.        This function fills the blank space with an (H) to signify home team, then creates a new blank space    and fills it with an (A) to signify away team, and re-orders the list so it reads:        'Home Team, (H), Away Team, (A), Game time'        Called later    """        for i in list:        while '' in i:            swap_positions(i, i.index(''), i.index('') - 2)            blank = i.index('')            blank_2 = i.index('') + 2            i[blank] = ' '            i.insert(blank_2, ' ')        # In[ ]:def scraping(date):        """    Web scraping code    """        url = "https://www.bbc.com/sport/football/scores-fixtures/" + date    html_content = requests.get(url).text    soup = BeautifulSoup(html_content, "html.parser")            tags = ["span", "h3"]    classes = (["gs-u-display-none gs-u-display-block@m qa-full-team-name sp-c-fixture__team-name-trunc",                  "sp-c-fixture__status-wrapper qa-sp-fixture-status",                  'sp-c-fixture__number sp-c-fixture__number--time', "sp-c-fixture__number sp-c-fixture__number--home",                  "sp-c-fixture__number sp-c-fixture__number--home sp-c-fixture__number--ft",                 "sp-c-fixture__number sp-c-fixture__number--home sp-c-fixture__number--live-sport",                  "sp-c-fixture__number sp-c-fixture__number--away sp-c-fixture__number--live-sport",                 "sp-c-fixture__number sp-c-fixture__number--away sp-c-fixture__number--ft"],               "gel-minion sp-c-match-list-heading")    scraper = soup.find_all(tags, attrs={'class': classes})    data = [str(l) for l in scraper]        data = clean_data(data) # Functiom call    home_and_away(data)     # Function call        data = [l for l in data if len(l) != 0]        return data# In[ ]:def change_time(scrape_data):        """    Alters match-time from UK time (site gives games in UK time) to whatever the local time is    by detecting users timezone automatically    """        curr_time = mytime.localtime()    curr_clock = mytime.strftime("%Y:%m:%d %H:%M:%S %Z %z", curr_time)    IST = pytz.timezone('Europe/London')    datetime_ist = mydatetime.now(IST)    london = datetime_ist.strftime("%Y:%m:%d %H:%M:%S %Z %z")    curr_hour, curr_min = curr_clock[-5:-2], curr_clock[14:16]    lndn_hour, lndn_min = london[-5:-2], london[14:16]        # Comparing time difference between London and user's local time    hour_diff = int(lndn_hour) - int(curr_hour)    min_diff = int(lndn_min) - int(curr_min)    if min_diff == 0:        min_diff = str(min_diff) + '0'    for k in scrape_data:        for indx, item in enumerate(k):                    if ":" in item:                    if min_diff == '00': # If there is no minute difference, change hours and keep minutes the same                    val = str(int(item[:item.index(":")]) - hour_diff) + item[item.index(":"):]                if min_diff != '00': # If there is a minutes difference, change hours and minutes                    val = str(int(item[:item.index(":")]) - hour_diff) + ":" + str(abs(min_diff) + int(item[item.index(":") + 1:]))                if int(val[val.index(":") + 1:]) >= 60:                     # If the new 'minutes' value is >= 60, add 1 to the hour value and subtract 60 from the minutes                    val = str(int(val[:val.index(":")]) + 1) + ":" + str(int(val[val.index(":") + 1:]) - 60)                if int(val[:val.index(":")]) >= 24:                    # If the new hours value is >= 24, subtract 24 from the hours and add a '+1' to the end                    # to signify game is taking place the following day                    val = "0" + str(int(item[:item.index(":")]) -24) + ":" + str(int(item[item.index(":") + 1:])) + " +1"                if val[val.index(":") + 1:] == '0':                    val = i + '0' # Add a second '0' to minutes value is there is only one                try:                    # If minutes value is between 1-9, add a '0' so that it reads '11:07' rather than                    # '11:7', for example                    if int(val[val.index(":") + 1:]) < 10 and int(val[val.index(":") + 1:]) > 0:                        colon = val.find(":")                        val = val[:colon + 1] + '0' + val[colon + 1:]                except ValueError:                        k[indx] = val                        continue                k[indx] = val        scrape_data = [[i.replace('&amp;', '&') for i in group] for group in scrape_data] # Brighton & Hove Albion problem        return scrape_data# In[ ]:def final_print(date):        """    Final print function        If user presses Enter while in terminal the scores will refresh without the user needing to enter    the date to search again. This way it can be called once during matchdays and work throughout the day    """    scrape_data = scraping(date)    data = change_time(scrape_data)        leagues = (['English Premier League', 'Spanish La Liga',  'German Bundesliga',  'Italian Serie A',             'French Ligue 1', 'Champions League', 'Europa League'])        data = [item for sublist in data for item in sublist]    data = [[i] if i in leagues else i for i in data]    ct = 0    my_data = []        while ct < len(data):        if type(data[ct]) == list:            data[ct].append('')            data[ct].append('')            data[ct].append('')            data[ct].append('')            data[ct].append('')            my_data.append(data[ct])            ct += 1            continue        else:            my_data.append(data[ct:ct+5])            my_data[-1].insert(0, '')            ct += 5            continue            today = datetime.date.today()    tomorrow = today + datetime.timedelta(days=1)    prev_2weeks = [today - datetime.timedelta(days=x) for x in range(15)]    nxt_2weeks = [tomorrow + datetime.timedelta(days=x) for x in range(14)]    prev_2weeks = prev_2weeks[::-1]    date_range = prev_2weeks + nxt_2weeks    first_date = date_range[0].strftime("%A, %B %d, %Y")    end_date = date_range[-1].strftime("%A, %B %d, %Y")        new_range = []    for i in date_range:        weekday = i.strftime("%A")        new_range.append(str(i) + ' (' + weekday + ')')        headings = ["League", "Home Team", "Score", "Away Team", "Score", "Match Time"]        return render_template("table.html", headings=headings, my_data=my_data, date=date, date_range=date_range, first_date=first_date, end_date=end_date, new_range=new_range)